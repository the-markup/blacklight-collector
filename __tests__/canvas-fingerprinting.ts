import { join } from "path";
import {
  sortCanvasCalls,
  getCanvasFingerprinters,
  getCanvasFontFingerprinters,
} from "../src/canvas-fingerprinting";
import { loadEventData } from "../src/utils";
import { BlacklightEvent } from "../src/types";

const TEST_DATA_DIR = join(__dirname, "test-data", "canvas-fingerprinting");
const FONT_TEST_DATA_DIR = join(__dirname, "test-data", "kohls-new.com");
let jsCalls: BlacklightEvent[];

beforeAll(async () => {
  const allCalls = loadEventData(TEST_DATA_DIR);
  jsCalls = allCalls
    .filter((m) => m.message.type.indexOf("JsInstrument") > -1)
    .map((m) => m.message);
});

afterAll(async () => {});
it("can sort a list of calls from the ndjson generated by the collector", async () => {
  const calls = sortCanvasCalls(jsCalls);
  expect(calls.cReads.size).toBe(1);
  expect(
    calls.cWrites.get("http://localhost:8125/canvas-fingerprinting.html")
  ).toContain("localhost");
  expect(calls.cWrites.size).toBe(1);
  expect(calls.cBanned.size).toBe(0);
  expect(
    calls.cTexts.get("http://localhost:8125/canvas-fingerprinting.html")
  ).toContain("BrowserLeaks,com <canvas> 1.0");
});

it("can identify canvas fp based on CITP criteria", async () => {
  const { fingerprinters } = getCanvasFingerprinters(jsCalls);
  expect(fingerprinters).toContain(
    "http://localhost:8125/canvas-fingerprinting.html"
  );
});

it("can identify font fingerprinting", async () => {
  const allCalls = loadEventData(FONT_TEST_DATA_DIR);
  jsCalls = allCalls
    .filter(
      (m) => m.message.type && m.message.type.indexOf("JsInstrument") > -1
    )
    .map((m) => m.message);
  const { canvas_font, text_measure } = getCanvasFontFingerprinters(jsCalls);
  expect(
    canvas_font["https://fc.kohls.com/2.2/w/w-756138/sync/js/"]
  ).toHaveLength(69);
  expect(
    text_measure["https://fc.kohls.com/2.2/w/w-756138/sync/js/"][
      "mmmmmmmmmmlli"
    ]
  ).toBe(204);
});
