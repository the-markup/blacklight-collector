import { join } from "path";
import {
  sortCanvasCalls,
  getCanvasFp,
  getCanvasFontFp
} from "../src/canvas-fingerprinting";
import { loadEventData } from "../src/parser";
import { BlacklightEvent } from "../src/inspector";

const TEST_DATA_DIR = join(__dirname, "test-data", "canvas-fingerprinting");

let jsCalls: BlacklightEvent[];

beforeAll(async () => {
  const allCalls = loadEventData(TEST_DATA_DIR);
  jsCalls = allCalls
    .filter(m => m.message.type.indexOf("JsInstrument") > -1)
    .map(m => m.message);
});

afterAll(async () => {});
it("can sort a list of calls from the ndjson generated by the collector", async () => {
  const calls = sortCanvasCalls(jsCalls);
  expect(calls.cReads.size).toBe(1);
  expect(
    calls.cWrites.get("http://localhost:8125/canvas-fingerprinting.html")
  ).toContain("localhost");
  expect(calls.cWrites.size).toBe(1);
  expect(calls.cBanned.size).toBe(0);
  expect(
    calls.cTexts.get("http://localhost:8125/canvas-fingerprinting.html")
  ).toContain("BrowserLeaks,com <canvas> 1.0");
});
it("can identify canvas fp based on CITP criteria", async () => {
  const canvasFp = getCanvasFp(jsCalls);
  expect(canvasFp).toContain(
    "http://localhost:8125/canvas-fingerprinting.html"
  );
});

it("can identify font fingerprinting", async () => {
  const calls = getCanvasFontFp(jsCalls);
  expect(
    calls.canvasFont.has("http://localhost:8125/canvas-fingerprinting.html")
  ).toBe(true);
  expect(
    calls.canvasFont.get("http://localhost:8125/canvas-fingerprinting.html")
  ).toContain("14px 'Arial'");
});
